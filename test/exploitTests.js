const { expect } = require('chai')
const { ethers } = require('hardhat')

const toETH = amt => ethers.utils.parseEther(String(amt))
const txValue = amt => ({ value: toETH(amt) })
const ethVal = n => Number(ethers.utils.formatEther(n))
const num = n => Number(n)

describe('Critical Vulnerability: lowestLeader reads uninitialized storage', function() {
  let PyramidGame, pyramidGame
  let deployer, user1, user2, user3, attacker

  beforeEach(async function() {
    [deployer, user1, user2, user3, attacker] = await ethers.getSigners()

    PyramidGame = await ethers.getContractFactory('PyramidGame')
    pyramidGame = await PyramidGame.deploy(txValue(1))
    await pyramidGame.deployed()
  })

  it('CRITICAL: lowestLeader returns uninitialized slot, bricking leadership claims', async function() {
    const leadersAddr = await pyramidGame.leaderboard()
    const leaders = await ethers.getContractAt('PyramidGameLeaderboard', leadersAddr)

    // Create only 3 leaders (slots 0, 1, 2 are filled)
    await pyramidGame.connect(user1).contribute(txValue(5))
    await pyramidGame.connect(user2).contribute(txValue(3))
    await pyramidGame.connect(user3).contribute(txValue(8))

    const totalSupply = await leaders.totalSupply()
    console.log('\nSetup:')
    console.log('  Total supply:', num(totalSupply), 'leaders')
    console.log('  Leader 0:', ethVal(await leaders.contributions(0)), 'ETH (deployer)')
    console.log('  Leader 1:', ethVal(await leaders.contributions(1)), 'ETH (user1)')
    console.log('  Leader 2:', ethVal(await leaders.contributions(2)), 'ETH (user2)')

    // Check what lowestLeader returns
    const [lowestIx, lowestAmount] = await leaders.lowestLeader()
    console.log('\nlowestLeader() returns:')
    console.log('  Index:', num(lowestIx))
    console.log('  Amount:', ethVal(lowestAmount), 'ETH')

    // The bug: it returns an uninitialized slot (3-11) with contribution = 0
    // This is less than any actual leader's contribution
    if (num(lowestIx) >= num(totalSupply)) {
      console.log('\nüö® BUG: lowestLeader returned uninitialized slot', num(lowestIx))
    }

    // Now demonstrate the brick: attacker accumulates PYRAMID and tries to claim leadership
    // First, make attacker NOT a leader but give them PYRAMID tokens
    await pyramidGame.connect(attacker).contribute(txValue(2))
    const attackerPyramid = await pyramidGame.balanceOf(attacker.address)
    console.log('\nAttacker has:', ethVal(attackerPyramid), 'ETH worth of PYRAMID tokens')

    // Attacker tries to claim leadership with more PYRAMID than "lowest" leader
    console.log('\nAttacker attempts to claim leadership...')

    // This should work: attacker has > 0 ETH in PYRAMID, "lowest" has 0 ETH
    // But it will REVERT because token ID', num(lowestIx), 'does not exist
    try {
      await pyramidGame.connect(attacker).claimLeadership()
      console.log('‚úÖ Leadership claim succeeded')
    } catch (error) {
      console.log('‚ùå EXPLOIT CONFIRMED: Leadership claim reverted!')
      console.log('   Reason:', error.message.split('(')[0].trim())
      // This should fail the test - proving the exploit exists
      expect.fail('Contract is bricked: cannot claim leadership due to uninitialized lowestLeader')
    }
  })

  it('DEMONSTRATION: lowestLeader should only check actual leaders', async function() {
    const leadersAddr = await pyramidGame.leaderboard()
    const leaders = await ethers.getContractAt('PyramidGameLeaderboard', leadersAddr)

    // Create leaders with different amounts
    await pyramidGame.connect(user1).contribute(txValue(10))
    await pyramidGame.connect(user2).contribute(txValue(5))
    await pyramidGame.connect(user3).contribute(txValue(15))

    const totalSupply = await leaders.totalSupply()

    console.log('\nAll leaders:')
    for (let i = 0; i < totalSupply; i++) {
      const contrib = ethVal(await leaders.contributions(i))
      console.log(`  Leader ${i}: ${contrib} ETH`)
    }

    const [lowestIx, lowestAmount] = await leaders.lowestLeader()
    console.log('\nlowestLeader() says:')
    console.log('  Index:', num(lowestIx))
    console.log('  Amount:', ethVal(lowestAmount), 'ETH')

    // It should return deployer (slot 0) with 1 ETH
    // But if it checks uninitialized slots, it returns slot 4+ with 0 ETH
    if (ethVal(lowestAmount) === 0) {
      console.log('‚ùå BUG: Returned uninitialized slot with 0 ETH')
      expect.fail('lowestLeader reading uninitialized storage')
    } else {
      console.log('‚úÖ Correctly identified lowest leader')
    }
  })
})
